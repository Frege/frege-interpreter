module frege.scriptengine.FregeScriptEngine where

import frege.compiler.Data (Symbol)
import frege.interpreter.FregeScriptCompiler
import frege.interpreter.FregeInterpreter
import frege.java.Net

data ScriptContext = mutable native javax.script.ScriptContext where
    native getAttribute :: ScriptContext -> String -> Int -> IO (Maybe Object)
    native setAttribute :: ScriptContext -> String -> Object -> Int -> IO ()
    pure native engineScope javax.script.ScriptContext.ENGINE_SCOPE :: Int
    pure native globalScope javax.script.ScriptContext.GLOBAL_SCOPE :: Int
    native getBindings :: ScriptContext -> Int -> IO Bindings
    
data SimpleScriptContext = mutable native javax.script.SimpleScriptContext where
  native new :: () -> IO SimpleScriptContext
    
data Bindings = mutable native javax.script.Bindings where
    native asMap "(java.util.Map)" :: Bindings -> IOMutable (JMap String Object)

initInterpreterState :: ScriptContext -> IO InterpreterState 
initInterpreterState session = do
  urlarr <- URLArray.new 0
  loader <- ClassLoader.current >>= URLClassLoader.new urlarr
  classesMaybe <- session.getAttribute "classes" ScriptContext.engineScope
  classes <- maybe (HashMap.new () :: IOMutable (JMap String ByteArr)) asClassesMap classesMaybe
  strMaybe <- session.getAttribute "script" ScriptContext.engineScope
  currentScript <-  maybe (return "") asString strMaybe
  modulePreludeMaybe <- session.getAttribute "modulePrelude" ScriptContext.engineScope
  modulePrelude <- maybe (return "") asString modulePreludeMaybe
  let interpreterState = InterpreterState {
      loader = loader,
      classes = classes,
      moduleName = "script.Main",
      currentScript = currentScript,
      modulePrelude = modulePrelude
  }
  return interpreterState

eval :: String -> ScriptContext -> IO ([String] | Maybe Object)
eval script context = do
    state <- initInterpreterState context
    (res, state) <- runInterpreter (interpret script context) state
    case res of
        Left _ -> return res
        Right _ -> do
            putContext context "classes" state.classes ScriptContext.engineScope
            putContext context "script" state.currentScript ScriptContext.engineScope
            return res
            
load :: String -> ScriptContext -> IO ([String] | ClassLoader)
load script context = do
    state <- initInterpreterState context
    evalInterpreter (loadIntp script context) state

compiledScript :: String -> ScriptContext -> IO ([String] | CompilationResult)
compiledScript script context = do
    state <- initInterpreterState context
    res <- evalInterpreter (compile script) state
    case res of
        CompilationSuccess c -> return $ Right res
        CompilationFailure err -> return $ Left err

evalCompiledScript :: CompilationResult -> String -> ScriptContext -> IO ([String] | Maybe Object)
evalCompiledScript compilation script context = do
    state <- initInterpreterState context
    (res, state) <- runInterpreter (interpretCompiled compilation script context) state
    case res of
        Left _ -> return res
        Right _ -> do
            putContext context "classes" state.classes ScriptContext.engineScope
            putContext context "script" state.currentScript ScriptContext.engineScope
            return res
    
loadIntp :: String -> ScriptContext -> Interpreter ([String] | ClassLoader)
loadIntp script context = do
    fregecRes <- compile script
    case fregecRes of
        CompilationSuccess (c@CompilationInfo{sourceInfo=sourceInfo,state=g}) -> do
          s <- Interpreter.get
          liftIO $ putContext context "classes" s.classes ScriptContext.engineScope
          return (Right g.sub.loader)
        CompilationFailure err -> return $ Left err
        
interpret :: String -> ScriptContext -> Interpreter ([String] | Maybe Object)
interpret script context = compile script >>= evaluate where
    evaluate c = interpretCompiled c script context

interpretCompiled :: CompilationResult -> String -> ScriptContext -> Interpreter ([String] | Maybe Object)    
interpretCompiled res script context = case res of
    CompilationSuccess (c@CompilationInfo{sourceInfo=sourceInfo,state=g}) ->
        case sourceInfo of
            Expression{variableName=var} -> fetchVariableValue var g context
            Module -> return $ Right Nothing
            Definitions -> do
                s <- Interpreter.get
                Interpreter.put $ s.{currentScript <- (++ newLine ++ script)}
                return $ Right Nothing
    CompilationFailure err -> return $ Left err

fetchVariableValue var g context = do
      let symbolMay = lookupVarSymbol g.thisTab var
      case symbolMay of
        Nothing -> return $ Right Nothing
        Just symbol -> fetchSymbolValue var symbol g context
        
fetchSymbolValue var SymL{alias} g context = 
    maybe (return $ Right Nothing) f $ alias.findit g where
      f s = fetchSymbolValue s.name.base s g context
fetchSymbolValue var symbol g context | isVariable g symbol = do
    state <- Interpreter.get
    bindings' <- liftIO $ ScriptContext.getAttribute context fregeBindingsKey ScriptContext.engineScope
    bindings <- liftIO $ maybe (HashMap.new () :: IOMutable (JMap String Object)) asBindingsMap bindings'
    isEmpty <- liftIO $ bindings.isEmpty
    when !isEmpty $ do
      clazz' <- liftIO $ g.sub.loader.loadClass preludeScriptClassName
      let clazz = either throw id clazz'
      liftIO $ injectValues bindings clazz
    v <- liftIO $ fetchFieldValue state.moduleName var g.sub.loader
    case v of
        Left err -> return $ Left [err.getMessage]
        Right value -> return $ Right $ Just (asObject value)
fetchSymbolValue _ symbol g _ = return $ Right Nothing

fregeBindingsKey = "frege.script.fregeBindings"
preludeScriptClassName = "frege.script.PreludeScript"

native fetchFieldValue frege.memoryjavac.JavaUtils.fieldValue :: 
  String -> String -> ClassLoader -> IO (Either ScriptException Object)
  
native injectValues frege.memoryjavac.JavaUtils.injectValues ::
  Mutable s (JMap String Object) -> Class a -> ST s ()
  
pure native asObject "(Object)" :: a -> Object
  
putContext :: ScriptContext -> String -> a -> Int -> IO ()
putContext context name value scope = 
    ScriptContext.setAttribute context name (asObject value) scope

native asClassesMap "(java.util.Map)" :: Object -> IOMutable (JMap String ByteArr)
native asString "(java.lang.String)" :: Object -> IO String
native asURLClassLoader "(java.net.URLClassLoader)" :: Object -> IO URLClassLoader
native asBindingsMap "(java.util.Map)" :: Object -> STMutable s (JMap String Object)