module frege.scriptengine.FregeScriptEngine where

import frege.compiler.Data (Symbol)
import frege.interpreter.FregeScriptCompiler
import frege.interpreter.FregeInterpreter
import frege.java.Net

data ScriptContext = native javax.script.ScriptContext where
    native getAttribute :: Mutable s ScriptContext -> String -> Int -> ST s (Maybe Object)
    native setAttribute :: Mutable s ScriptContext -> String -> Object -> Int -> ST s ()
    pure native engineScope javax.script.ScriptContext.ENGINE_SCOPE :: Int
    pure native globalScope javax.script.ScriptContext.GLOBAL_SCOPE :: Int
    native getBindings :: Mutable s ScriptContext -> Int -> STMutable s  Bindings
    
data SimpleScriptContext = mutable native javax.script.SimpleScriptContext where
  native new :: () -> IO SimpleScriptContext
    
data Bindings = native javax.script.Bindings where
    native asMap "(java.util.Map)" :: Bindings -> STMutable s (JMap String Object)

initInterpreterState :: Mutable s ScriptContext -> ST s CompilationOpts
initInterpreterState session = do
  loaderMaybe <- session.getAttribute "classloader" ScriptContext.engineScope
  loader <- maybe (MemoryClassLoader.new ()) (return asMemoryClassLoader) loaderMaybe
  strMaybe <- session.getAttribute "script" ScriptContext.engineScope
  currentScript <-  maybe (return "") asString strMaybe
  cl <- Mutable.freeze loader
  return $ CompilationOpts {
                              loader = cl,
                              predefs = "",
                              transformDefs = id
                           }
  return interpreterState

eval :: String -> Mutable s ScriptContext -> ST s ([String] | Maybe a)
eval script context = do
    opts <- initInterpreterState context
    case compileWithOpts script opts of
        Left g -> return $ showMessages res
        Right (CompilationSuccess {classLoader=loader,sourceInfo=srcType,state=g})-> do
            putContext context "classloader" loader ScriptContext.engineScope
            putContext context "script" state.currentScript ScriptContext.engineScope
            return res
            
load :: String -> ScriptContext -> IO ([String] | ClassLoader)
load script context = do
    state <- initInterpreterState context
    evalInterpreter (loadIntp script context) state

compiledScript :: String -> ScriptContext -> IO ([String] | CompilationResult)
compiledScript script context = do
    state <- initInterpreterState context
    res <- evalInterpreter (compile script) state
    case res of
        CompilationSuccess c -> return $ Right res
        CompilationFailure err -> return $ Left err

evalCompiledScript :: CompilationResult -> String -> ScriptContext -> IO ([String] | Maybe Object)
evalCompiledScript compilation script context = do
    state <- initInterpreterState context
    (res, state) <- runInterpreter (interpretCompiled compilation script context) state
    case res of
        Left _ -> return res
        Right _ -> do
            putContext context "classes" state.classes ScriptContext.engineScope
            putContext context "script" state.currentScript ScriptContext.engineScope
            return res
    
loadIntp :: String -> ScriptContext -> Interpreter ([String] | ClassLoader)
loadIntp script context = do
    fregecRes <- compile script
    case fregecRes of
        CompilationSuccess (c@CompilationInfo{sourceInfo=sourceInfo,state=g}) -> do
          s <- Interpreter.get
          liftIO $ putContext context "classes" s.classes ScriptContext.engineScope
          return (Right g.sub.loader)
        CompilationFailure err -> return $ Left err
        
interpret :: String -> ScriptContext -> Interpreter ([String] | Maybe Object)
interpret script context = compile script >>= evaluate where
    evaluate c = interpretCompiled c script context

interpretCompiled :: CompilationResult -> String -> ScriptContext -> Interpreter ([String] | Maybe Object)    
interpretCompiled res script context = case res of
    CompilationSuccess (c@CompilationInfo{sourceInfo=sourceInfo,state=g}) ->
        case sourceInfo of
            Expression{variableName=var} -> fetchVariableValue var g context
            Module -> return $ Right Nothing
            Definitions -> do
                s <- Interpreter.get
                Interpreter.put $ s.{currentScript <- (++ newLine ++ script)}
                return $ Right Nothing
    CompilationFailure err -> return $ Left err

fetchVariableValue var g context = do
      let symbolMay = lookupVarSymbol g.thisTab var
      case symbolMay of
        Nothing -> return $ Right Nothing
        Just symbol -> fetchSymbolValue var symbol g context
        
fetchSymbolValue var SymL{alias} g context = 
    maybe (return $ Right Nothing) f $ alias.findit g where
      f s = fetchSymbolValue s.name.base s g context
fetchSymbolValue var symbol g context | isVariable g symbol = do
    state <- Interpreter.get
    bindings' <- liftIO $ ScriptContext.getAttribute context fregeBindingsKey ScriptContext.engineScope
    bindings <- liftIO $ maybe (HashMap.new () :: IOMutable (JMap String Object)) asBindingsMap bindings'
    isEmpty <- liftIO $ bindings.isEmpty
    when !isEmpty $ do
      clazz' <- liftIO $ g.sub.loader.loadClass preludeScriptClassName
      let clazz = either throw id clazz'
      liftIO $ injectValues bindings clazz
    v <- liftIO $ fetchFieldValue state.moduleName var g.sub.loader
    case v of
        Left err -> return $ Left [err.getMessage]
        Right value -> return $ Right $ Just (asObject value)
fetchSymbolValue _ symbol g _ = return $ Right Nothing

fregeBindingsKey = "frege.script.fregeBindings"
preludeScriptClassName = "frege.script.PreludeScript"

native fetchFieldValue frege.memoryjavac.JavaUtils.fieldValue :: 
  String -> String -> ClassLoader -> IO (Either ScriptException Object)
  
native injectValues frege.memoryjavac.JavaUtils.injectValues ::
  Mutable s (JMap String Object) -> Class a -> ST s ()
  
pure native asObject "(Object)" :: a -> Object
  
putContext :: ScriptContext -> String -> a -> Int -> IO ()
putContext context name value scope = 
    ScriptContext.setAttribute context name (asObject value) scope

native asMemoryClassLoader "(frege.memoryjavac.MemoryClassLoader)" :: a -> MemoryClassLoader
native asString "(java.lang.String)" :: Object -> IO String
native asURLClassLoader "(java.net.URLClassLoader)" :: Object -> IO URLClassLoader
native asBindingsMap "(java.util.Map)" :: Object -> STMutable s (JMap String Object)